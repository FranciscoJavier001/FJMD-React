{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","prototype","PropTypes","func","isRequired","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"2MAGaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAAmB,EAERC,mBAAS,IAFD,mBAErCC,EAFqC,KAEzBC,EAFyB,KAkB5C,OAGI,aAHK,CAGL,QAAMC,SAbW,SAACC,GAClBA,EAAEC,iBAECJ,EAAWK,OAAOC,OAAS,IAE1BR,GAAc,SAAAS,GAAI,OAAKP,GAAL,mBAAoBO,OACtCN,EAAc,MAOlB,SACI,uBACIO,KAAK,OACLC,MAAOT,EACPU,SArBc,SAACP,GACvBF,EAAcE,EAAEQ,OAAOF,aA0B/BZ,EAAYe,UAAY,CACpBd,c,OAAee,EAAUC,KAAKC,Y,mCC9BrBC,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DACbC,EADa,iDACmCC,UAAUH,GAD7C,sDAEAI,MAAMF,GAFN,cAEbG,EAFa,gBAGIA,EAAKC,OAHT,uBAGXC,EAHW,EAGXA,KAEFC,EAAOD,EAAKE,KAAI,SAAAC,GAAQ,IAAD,EACzB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QATvB,kBAcZM,GAdY,4CAAH,sDCHPO,EAAc,SAAC,GAAkB,IAAjBH,EAAgB,EAAhBA,MAAOV,EAAS,EAATA,IAEhC,OAGI,cAHK,CAGL,OAAKc,UAAU,yCAAf,UAEI,qBAAKC,IAAKf,EAAKgB,IAAKN,IAEpB,4BAAIA,QCPHO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAAe,ECAb,SAACA,GAAa,MACZlB,mBAAS,CAC/ByB,KAAM,GACNa,SAAS,IAHyB,mBAC/BC,EAD+B,KACxBC,EADwB,KAkBtC,OAXAC,qBAAW,WACPxB,EAAQC,GACPwB,MAAK,SAAAC,GAEEH,EAAS,CACLf,KAAMkB,EACNL,SAAS,SAGtB,CAACpB,IAEGqB,EDhBwBK,CAAa1B,GAAhCa,EAFyB,EAE9BN,KAAaa,EAFiB,EAEjBA,QAEpB,OAEI,cADA,CACA,sBAEI,oBAAIJ,UAAU,yCAAd,SAAwDhB,IAGvDoB,GAAW,mBAAGJ,UAAU,+BAAb,qBAEZ,qBAAKA,UAAU,YAAf,SAEQH,EAAOJ,KAAI,SAAAC,GAAG,OACV,aADgB,CACf,EAAD,eAEQA,GADCA,EAAIC,aEjBxBgB,EAAe,WAAO,IAAD,EAEM7C,mBAAS,CAAC,eAFhB,mBAEvB8C,EAFuB,KAEX/C,EAFW,KAQ9B,OACI,qCAEI,8CAIA,cAAC,EAAD,CAAaA,cAAeA,IAC5B,uBAGA,6BAEQ+C,EAAWnB,KAAI,SAAAT,GAAQ,OAEnB,aAFyB,CAExB,EAAD,CAEAA,SAAUA,GADLA,Y,MCrB7B6B,IAASC,OACL,cAAC,EAAD,IACFC,SAASC,eAAe,W","file":"static/js/main.c08127cb.chunk.js","sourcesContent":["import React, { useState } from 'react'\nimport PropTypes from 'prop-types';\n\nexport const AddCategory = ({setCategories}) => { //** Agregamos el AddCategory pero va directamente al setCategories y va a volver a renderizar, y se recibe props */\n\n    const [inputValue, setInputValue] = useState('') /** Estas son las dos funciones que tiene el inputvalue (donde escribimos) y abajo ya quedo declarado  */\n\n    const handleInputChange = (e) => { \n        setInputValue(e.target.value) /** Esto me permite cambiar el texto */\n    }\n\n    const handleSubmit = (e) => { /** Aqui hacemos la peticion para que salga en el DOM, y que se vea reflejado cuando damos enter  */\n        e.preventDefault(); /** Esto evita el refresh de la pagina */\n\n        if(inputValue.trim().length > 0){ //** Solo si el arreglo es mayor de 2 que empieze a buscar */\n            //** Asi le hizimos para que la primera saliera arriba */\n            setCategories(cats => [inputValue, ...cats,]); //** El primer callback es el estado anterior y luego regresa un nuevo estado con todos los nuevos arreglos, se llama a esta instruccion para tener acceso al arreglo, porque se esta pasando como argumento */\n            setInputValue('');\n        }\n    }\n\n    return ( /** Aqui directamente ya estamos en el DOM */\n        // El Form agrupa todo lo demas, por eso no hace falta el fragment\n        //** Aqui le decimo que va a responder a handleSubmit, osea cuando de enter */\n        <form onSubmit={handleSubmit}>  \n            <input \n                type=\"text\"\n                value={inputValue}\n                onChange={handleInputChange} /** Aqui le doy el valor para cambiarlo */\n                />\n            </form>\n    )\n}\n\nAddCategory.prototype = { /** Para que utilicen nuestro componente con el pequeÃ±o candado con los argumentos que estoy esperando, esta es la peticion de los proptypes  */\n    setCategories: PropTypes.func.isRequired\n}","//** Esta en la carpeta helpers y esta carpeta son funciones que hacen un trabajo en especifico, pueden recibir argumentos, los procesan y pueden hacer un return */\n// Esta es la peticion de getGifs\n//** Lo que esto hace es hace la peticion http, trae las imagenes y las procesa y las retorna */\n\n//** Se hace la peticion, pero necesitamos la categoria, por lo cual hay que mandarla como argumento, tenemos el, recuerda como es async esta funcion no es que regresa los gifs, regresa una promesa que resuelve la coleccion de imagenes */\nexport const getGifs = async (category) => {\n    const url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&api_key=tfRgcwv7vxAyL3vMQapLiD0NQw3148nH`;\n    const resp = await fetch(url);\n    const { data } = await resp.json();\n\n    const gifs = data.map(img => { /** Nos envia el arreglo con los parametros solicitdos */\n        return {\n            id: img.id,\n            title: img.title,\n            url: img.images?.downsized_medium.url\n        }\n    });\n    // console.log(gifs); //** Bien, aqui se ponia para ver que arreglo esta regresando, aqui se inicializaron para que se mandara la respuesta */\n\n    return gifs;\n    \n}\n","import React from 'react'\n\nexport const GifGridItem = ({title, url}) => { //** Estos son los parametros que se reciben en el map del GifGrid.js */\n\n    return ( //** Es lo que retorna el arreglo de GifGridItem */\n        // Estos son los estilos de bootstrap, y aqui vemos que solo se hace el llamado de los parametros dichos en el getGifs.js\n        // Como lo vez aqui el div con el className se nos puso a modo de bootstrap, le ponemos el nombre, que en este caso es card y luego la animamos como queramos\n        <div className=\"card animate__animated animate__fadeIn\"> \n            {/* Estos son los parametros que trae cada imagen */}\n            <img src={url} alt={title}/> \n            {/* Es el titulo que va abajo */}\n            <p>{title}</p>\n        </div>\n    )\n}\n","import React  from 'react'\nimport { useFetchGifs } from '../hooks/useFetchGifs'\nimport { GifGridItem } from './GifGridItem';\n\nexport const GifGrid = ({ category }) => { //** Aqui lo exportamos para que lo pueda utilizar GifExpertApp, el argumento es category */\n\n    const {data:images, loading} = useFetchGifs(category); //** Es la peticion http para traer las imagenes que corresponden a la categoria, con los : se renombra en la desestructuracion */\n\n    return (\n        // Cuando haya que regresar 2 objetos usa el fragment\n        <>\n            {/* Este h3 son donde se quedan guardadanas nuestras busquedas */}\n            <h3 className=\"card animate__animated animate__fadeIn\">{category}</h3>\n\n            {/* Esta es cuando se estan cargando */}\n            {loading && <p className=\"card animate__animated flash\">Loading</p>}\n\n            <div className=\"card-grid\">\n                {\n                    images.map(img => ( //** Asi hago un return de objetos */\n                        <GifGridItem //** Aqui se va a mostrar */\n                            key={img.id} //** Este es el return ue se me hizo, de id y de img */\n                            {...img} //** Operador spred de img  */\n                        />\n                    ))\n                }\n            </div>\n        </>\n    )\n}\n","//** use = Es un Hook, y no es mas que una funcion  */\nimport { useEffect, useState } from \"react\"\nimport {getGifs} from '../helpers/getGifs'\n\nexport const useFetchGifs = (category) => { //** Esta va a ser la peticion automatica cuando se carge porque cambie la categoria */\n    const [state, setState] = useState({ //** El useState le dice a los componentes que algo cambio y deben renderizarse */\n        data: [], //** Este es su estado inicial */\n        loading: true //** Este es su estado inicial */\n    });\n\n    //** Esto retorna una promesa por lo cual se pone un then, para tener las imgs y la funcion de fecha y llamamos al setImagenes  */\n    useEffect (() => { //** Este lo utilizamos para que no se haga un llamado de todas al agregar una nueva categoria, recibe la funcion que quiero ejecutar  */\n        getGifs(category) //** Aqui se hace el llamado a la funcion que queremos */\n        .then(imgs => {\n\n                setState({ //** Este codigo significa que solo quiero que se renderize la primera vez que se llama, ya despues no */\n                    data: imgs,\n                    loading: false\n                });\n            })\n    }, [category]) //** Aqui es un arreglo de dependencias, y solo se va a disparar una unica vez, y se la categoria cambia, entonces solo va a ejecutar otra vez este useEffect */\n\n    return state; //{data:[], loading: true}; //** El state es el estado del useState, y cuando cambia es lo que me retorna */\n}\n","import React, { useState } from 'react'\nimport { AddCategory } from './components/AddCategory'\nimport { GifGrid } from './components/GifGrid' //** Es para agregar el category, desde el GifGrid */\n\nexport const GifExpertApp = () => {\n\n    const [categories, setCategories] = useState(['Death Note']) //** Se crea una constante donde vamos a agregar cosas, recuerda este es un hook, setCategories es la instruccion para agregar categorias */\n\n    //setCategories(cats => [...cats, 'HunterXHunter']); /** El UseState me dio la habilidad de hacerlo directamente con el setCategories */\n\n    /** Para crear nuevos componentes en React debemos de crear una carpeta en \"src\" llamada components y ponerle un nombre descriptivo como \"AddCategory\" y escribimos rafc y ahi escribimos lo que tengamos que escribir y se muestra en el dom, luego agrego el componente  */\n\n    return ( \n        <>\n        {/* Esta es la tarea que dejo */}\n            <h2>GifExpertApp</h2> \n            {/* Siempre asegurate que se importe, este ya se importo arriba */}\n            {/* setCategories es la instruccion para agregar categorias */}\n            {/* Podemos pasarle caegorias por aqui, es decir, le pasamos la referencia a setCategories */}\n            <AddCategory setCategories={setCategories}/>\n            <hr/>\n\n            {/* Una lista ordenada */}\n            <ol>\n                {\n                    categories.map(category => ( /** El Map barre el arreglo que ahora se llama category, porque esto es una funcion de flecha que ya inicializamos y podemos mandar llamar cuando necesitemos con el return */\n                        // GifGrid es el componente que hace la peticion \"http\" al servidor, para que regrese un objeto definido como category en el GifGrid, que esta evaluando desde el GifGrid, y este necesita el key\n                        <GifGrid  \n                        key={category}\n                        category={category}\n                        />\n                        // <li key={category}>{category}</li> /** Muestra el arreglo con cada cosa que esta ahi dentro */\n                    ))\n                }\n            </ol>\n\n        </>\n    )\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { GifExpertApp } from './GifExpertApp';\n\nimport './index.css';\n\nReactDOM.render(\n    <GifExpertApp/>,\n  document.getElementById('root')\n);"],"sourceRoot":""}